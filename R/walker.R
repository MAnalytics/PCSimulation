#' @title A landscape walker
#' @description A dynamic object capable of walking
#' across any landscape (constraint or unconstraint),
#' in line with an in-built transition matrix, and
#' specified spatial and temporal properties. The transition
#' matrix defines a two-state status, namely; the `exploration`
#' and the `action` states. See vignette for details.
#' @param n (integer) Number of events
#' to be generated by a walker.
#' @param s_threshold (numeric) Spatial threshold of
#' a walker. This is the spatial range within which events are
#' re-generated (or repeated) by a walker.
#' Default: \code{250} (in the unit as the polygon shapefile (below))
#' @param step_length (numeric) A maximum step taken at a time
#' by a walker from one state to the next.
#' @param poly (An sf or S4 object)
#' A polygon shapefile within which
#' event origins are to be generated.
#' @param resistance_feat (An S4 object) Optional
#' shapefile representing spaces across landscape
#' within which event
#' origins are not allowed. Default: \code{NULL}.
#' @param field A number in the range of \code{[0-1]}
#' (i.e. resistance values) to
#' assign to all features covered by `shp`; or
#' the name of a numeric field to extract such
#' resistance values for different feature classes.
#' The resistance value `0` and `1` indicate the
#' lowest and the highest restrictions, respectively,
#' to an event occuring within the space occupied
#' by a feature.
#' @param coords a vector of the form c(x, y) giving the
#' initial coordinates of a walker (i.e., coordinates
#' of origins).
#' Default value is \code{c(0,0)} for an
#' arbitrary square space.
#' @param pt_itx (logical) Check whether any of the
#' specified initial origin coordinates
#' falls outside the boundary.
#' Default: \code{TRUE}.
#' @param show.plot (TRUE or False) To show the time series
#' plot. Default is \code{FALSE}.
#' @usage walker(n = 5, s_threshold = 250, step_length = 20,
#' poly = NULL, resistance_feat=NULL, field = NA, coords=c(0,0),
#' pt_itx = TRUE, show.plot = FALSE)
#' @examples
#' data(camden_boundary)
#' path <- walker(n = 5, s_threshold = 250, step_length = 20,
#' poly=camden_boundary, resistance_feat=NULL, field = NA,
#' coords = c(0,0), pt_itx = TRUE, show.plot = FALSE)
#' #plot(path)
#' @details
#' Walks freely in all directions in accordance with a
#' transition matrix, but avoids obstacles (i.e., the
#' `resistance_feat`, if provided) along the way.
#' @return Returns a trace of walker's path, and the
#' corresponding events.
#' @references
#' #https://google.co.uk
#' @importFrom dplyr select filter
#' @importFrom SiMRiv species transitionMatrix
#' state.CRW simulate resistanceFromShape
#' @importFrom chron chron
#' @importFrom stats time
#' @importFrom sf st_intersects st_as_sf st_centroid
#' st_point
#' @importFrom stringr str_split str_remove_all
#' @export

walker <- function(n = 5, s_threshold = 250, step_length = 20,
                   poly=NULL, resistance_feat=NULL,
                   field = NA,
                   coords = c(0,0), pt_itx = TRUE, show.plot = FALSE){

  #output holder
  output <- list()

  points <- text <- sn <- x <- y <- X3 <- NULL

  #test polygon geometry
  if(!is.null(poly)){
    #-----
    poly_tester(poly)
    #-----
  }

  if(pt_itx == TRUE){
    if(is.null(poly)  & coords[1]!=0 & coords[2]!=0){
      stop("`poly` argument is NULL!")
    }

  #poly defined but not coords, then get centroid
  if(!is.null(poly) & coords[1]==0 & coords[2]==0){ #extract centroid coords
    cent_xy <- as.character(st_centroid(st_as_sf(poly)$geometry))
    cent_xy <- str_remove_all(cent_xy, "[(c,)]")
    cent_xy_x <-  as.numeric(str_split(cent_xy, " ", 2)[[1]][1])
    cent_xy_y <-  as.numeric(str_split(cent_xy, " ", 2)[[1]][2])
    cent_xy <- c(cent_xy_x, cent_xy_y)
    #set coords
    coords <- cent_xy
    }
  }

  #configure walker
  Walker <- species(
  state.CRW(0.005) + state.CRW(0.99),
  transitionMatrix(exp(-6.25679 + 1.26863*log(n)), #
                   0.70))
  #-6.25679 + 1.26863*log(n) is the
  #power regression that relate x and y (see 'calibra..R')

  #create the landscape resistance raster
  #create boundary
  #test polygon geometry
  if(!is.null(poly)){
    landscape <- space_restriction(shp = poly,
                                   res = 50, binary = TRUE)

    #update the landscape resistance map
    if(!is.null(resistance_feat)){
      landscape <- space_restriction(shp = resistance_feat,
                                     baseMap = landscape,
                                    res = 50, field = field)
    }
    #plot(landscape)
    #check point polygon intersection
    if(pt_itx == TRUE){
      st_int <- st_intersects(st_as_sf(poly),
                              st_point(coords, dim="XY"))
      st_int_yes <- as.numeric(st_int)
    }
  }

  #plot(landscape)
  #does the point fall within the boundary?

  #plot(poly)
  #plot(st_point(x = coords, dim = "XY"))

  #meaning 1-step/hrs
  Walker <- (Walker + step_length) * s_threshold

  if(is.null(landscape)){
    sim <- simulate(Walker, time=200, coords)
  }

  if(!is.null(landscape)){
    sim <- simulate(Walker, time=200, resist = landscape, coords)
  }

  #200 is the no of time.steps to be simulated
  #extract event locations
  sim_events <- data.frame(sim)
  colnames(sim_events) <- c("X1","X2","X3")
  sim_events <- sim_events %>%
    filter(X3 == 1)
  #200 (number of steps per origin)..
  #was used in the calibration ##nrow(sim) ##length(which(sim[,3]==1))

  #create hour sequence
  # hourly unit
  hm <- merge(0:23, seq(0, 0, by = 0))
  hour_seq <- chron(times. = paste(hm$x, ':', hm$y, ':', 0))

    #if event is present
    if(nrow(sim_events) >= 1){

      #assign random (but progressing) time to events
      hr_sample <- sample(hour_seq, nrow(sim_events), replace = TRUE)
      hr_sample <- hr_sample[order(hr_sample)]

      sim_events_ <- cbind(sim_events, 1:nrow(sim_events), hr_sample)

      if(show.plot == TRUE){
        plot(sim, type="l", asp=1, col="gray80")
        points(sim_events_, col="red")
        text(sim_events_[,1], sim_events_[,2],
         labels=sim_events_[,4], cex= 0.7, pos=3)
      }

      colnames(sim_events_) <- c("x","y","yes","sn", "time")

      sim_events_ <- data.frame(sim_events_) %>%
        dplyr::select(sn, x, y, time)


    #output$intersection <- st_int_yes  #poly-point intersection
    #output$p_events <- sim_events_
    output <- sim_events_

    return(output)
    }

}
