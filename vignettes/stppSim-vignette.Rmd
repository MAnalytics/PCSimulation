---
title: 'stppSim: An R package for synthesizing spatiotemporal point patterns - A user
  guide'
author: |
  | Monsuru Adepeju^[Big Data Centre, Manchester Metropolitan University, Manchester, M156BH, UK, m.adepeju@mmu.ac.uk]
date: |
  | ``r Sys.Date()``
  | `Date:`
output:
  pdf_document: default
  html_document:
    df_print: paged
urlcolor: blue
linestretch: 1.5
fontsize: 16pt
bibliography: references.bib
abstract: With increasingly limited availability of fine-grained spatially and temporally
  stamped point data, the `stppSim` provides an alternative source of data for a wide
  range of research in social and life sciences. It generates artificial spatio-temporal
  (ST) point patterns through the integration of microsimulation and agent-based models.
  Allows a user to define the behaviours of a set of 'walkers' (agents, objects, persons,
  etc.,) whose interactions with the spatial (landscape) and the temporal configurations produce
  new point events. The resulting point cloud and patterns can be measured, analyzed, and      
  processed for spatial and/or temporal model testings and evaluations.
vignette: |
  %\VignetteIndexEntry{stppSim: An R package for synthesizing spatiotemporal point patterns - A user guide} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r functions, include=FALSE}
# A function for captioning and referencing images
fig <- local({
  i <- 0
  ref <- list()
  list(
    cap=function(refName, text) {
      i <<- i + 1
      ref[[refName]] <<- i
      paste("Figure ", i, ": ", text, sep="")
    },
    ref=function(refName) {
      ref[[refName]]
    })
})
```

```{r eval = TRUE, echo=FALSE}
path <- "C:/Users/monsu/Documents/GitHub/stppSim backup/figs/"
```

## Introduction

In many research contexts, access to fine-grained spatiotemporal (ST) point data have been severely restricted due to privacy concerns. The `R-stppSim` package has been designed to address this challenge by presenting a framework that is capable of mimicking a real-life data, through the integration of microsimulation and agent-based techniques, in order to generate new point events in space and time. The framework comprises a set of 'walkers' (agents, objects, persons, etc.) with modifiable movement characteristics, the landscape (spatial components), and the temporal configurations. It is The interaction between these three elements that give rise to new point events, which can be processed, measured, and manipulated for further applications.

The package contains two key functions for synthesizing new datasets; (i) `psim_artif` and (ii) `psim_real`. The `psim_artif` synthesizes point patterns purely from users specifications. That is, the simulation does not depend on any existing point data. On the other hand, `psim_real` synthesizes point patterns based on a sample real data set. The latter is particularly applicable to situations where only sparse version of a data set is available for an area. The function learns (or extracts) certain spatial and temporal characteristics of the sample data, and then extrapolates to generate full data set. The potential applications of `stppSim` include generation of offending data sets (crime), disease infection data sets, and foraging data of wild animals. 

## Simulation Parameters

The simulation parameters are in relation to three elements, namely; the '`walkers (agents)`', the `landscape` (spatial), and the `temporal dimension`. The parameters are described as follow: 

### Walkers (agents).

The walkers are defined primarily by the following characteristics:

* ***Origins*** - The walkers emanate from a set of origins that are distributed randomly across the landscape or origins defined from a sample of real point data. Origins are defined in terms of `xy` coordinates. In criminological application, a human offender can be modelled as a walker originating from his residence (origin). The `origins` of walkers typically exhibit two types of concentration: `nucleated` and `dispersed` (`ref`). A `nucleated` concentration is the one in which all origins concentrate around one focal point, while a `dispersed` concentration has no one particular focus, but could have multiple mini focal points (see fig. 1). 

```{r fig1, warnings=FALSE, echo=FALSE, out.width="90%", out.height="100%", fig.align = "right", fig.cap="Type of origin concentration"}
knitr::include_graphics(paste(path, "origins.png", sep=""))
```

* ***Movement*** - Walkers are configured to move in any direction and to be aware of obstacles (restrictions) on their path. The movements are controlled primarily by an in-built transition matrix (TM) definig two transitional states, namely; an `exploratory` state (in which a walker is merely exploring the environment) and a `performative` state (in which a walker is performing an action). The stochastic properties of the TM ensure variations in the behavioral patterns amongst the walkers.
In order to switch from one state to the next, a categorical distribution is assigned to the latent state variable $z_{it}$. So, every time step may be assigned to a movement behaviour state, independent of the previous state: $$z_t \sim Categorical(\Psi{_{1t}}, \Psi{_{2t}})$$ Such that $\Psi{_{i}}$ = Pr$(z_t = i)$, where $\Psi{_{i}}$ is the fixed probability of being in state $i$ at time $t$, and $\sum_{i=1}^{z}\Psi{_{i}}=1$

* ***Spatial threshold, k*** - The perception range of a walker at a given location. The parameter `k` is generally updated as a walker moves to a new location. A natural method for choosing the smoothing parameter is to plot out the data choose the estimate that is most in accordance with one's prior ideas about the `k` value. For many applications this approach will be perfectly satisfactory. The package also provides the users with the option to estimate the [optimal value](https://www.taylorfrancis.com/books/mono/10.1201/9781315140919/density-estimation-statistics-data-analysis-silverman) of `k` based on the sample data set, and then utilize for data simulation.

* ***Steps*** - The maximum step taken by a walker as he moves from one location to another. This defines the speed of a walker across the space. The `steps` should be carefully defined, particularly, when movements are restricted along narrow paths, such as route network. In this case, a step value must be smaller than the width of the paths. 
* ***Proportional ratios*** - Defines the percentage of total events emanating from a small number of the most active origins. A `20:80` proportional ratios implies that 20% of origins (walkers) generates 80% of the point events.

### Landscape (spatial)

The followings are the key properties of a landscape:

* ***Boundary*** - A landscape is bounded - defined by a polygon shapefile (`poly`) or by the spatial extent of the sample point data.

* ***Restrictions*** - Defined as a raster layer. Typically defines two features: (i) Areas outside the boundary with the maximum restriction level (i.e., `1` - implying no movement), and (ii) Features within the boundary serving as obstructions to movement, e.g., certain land use type or  topography, such as a fenced place and hills. Using the example of Camden boundary data, we can define the boundary within which the simulation is confined:

```{r eval=FALSE, echo=TRUE}
#load shapefile data
load(file = system.file("extdata", "camden.rda", package="stppSim"))
#extract boundary shapefile
boundary = camden$boundary # get boundary
#compute the restriction map
restrct_map <- space_restriction(shp = boundary,res = 20, binary = TRUE)
#plot the restriction map
plot(restrct_map)
```

Now, setting the `restrct_map` above as the `basemap`, and then stack the land use features to define the restrictions within the area,

```{r eval=FALSE, echo=TRUE}
# get landuse data
landuse = camden$landuse 

#compute the restriction map
full_restrct_map <- space_restriction(shp = landuse, 
     baseMap = restrct_map, res = 20, field = "restrVal", background = 1)

#plot the restriction map
plot(full_restrct_map)
```

```{r fig2, echo=FALSE, out.width="100%", out.height="100%", fig.align = "right", fig.cap="Restriction map"}
knitr::include_graphics(paste(path, "restrictionMap.png", sep=""))
```

From figure 2, the land use feature has three classes, with each class having it's different restriction value {e.g., `Leisure` (0.5); `Sports` (0.7); and `Green` (0.9)}, 


* ***Focal points*** - Locations (origins) with relatively higher concentration of opportunities (to event occurrences). This is only specified when simulating data from scratch. A user will typically specify the number of focal points to simulate. An example of a focal point is the `city/town centre` within a city. An additional parameter `mfocal` allows a user to specify the central location of the ***main focal area***. The `mfocal` is synonymous to the center of the city's main central area. The default value of `mfocal` is `NULL` in which a random
coordinate is chosen within the study area. Also, a parameter `foci separation` allows a user to specify the proximity of the focal points to one another (values range from 1 to 100). 

### Temporal dimension

The following parameters define the temporal dimension:

* ***Long-term trend*** - Defines the long-term direction of the time series to be simulated. This can be `stable`, `rising` or `falling`. If either `rising` or `falling`, the slope can be made `gentle` or `steep`. Only applies to simulation from scratch. 

* ***Short-term patterns*** - Defines the short-term variation in events total over time. This is controlled by specifying the first seasonal peak point of the time series. A  `90` day first peak implies a seasonal cycle of `180` days.

```{r fig3, echo=FALSE, out.width="70%", out.height="50%", fig.align = "center", fig.cap="Global trends and patterns"}
knitr::include_graphics(paste(path, "trend.png", sep=""))
```

Figure 3 shows different anchors of global temporal trend and patterns with the first peak at different times, starting with 90 days. The number of seasonal cycles increases with earlier first peaks. Note: this is only applicable to simulation of data from scratch. The trend and patterns are learned if simulating data set from a sample real data.

* ***time bin*** - Time to reset all walkers. Typically 1 day. 

## Installation of `stppSim`

From an R console, type:

```{r eval=FALSE, message=FALSE, warning=FALSE}
install.packages("stppSim")
#To install the developmental version of the package, type:
remotes::install_github("MAnalytics/stppSim")
```

Note: `remotes` is an extra package that needed to be installed prior to the running of this code. 

```{r eval=FALSE, message=FALSE, warning=FALSE}
#Now, load the package,
library(stppSim)
```


## Synthesizing `stpp` from scratch

To simulate point patterns from scratch, specify `n_events` - **the number of points to simulate**. It is recommended that a vector of values is provided, rather than a single value. For example, `n_events = c(200, 500, 1000, 2000)`. The output is generated as a list comprising the separate results of the values. 

### Example 

Given a boundary shapefile of Camden Borough of London (with another shapefile containing land use features, as landscape restrictions), the ST point patterns can be generated as follows: 

```{r eval=FALSE, echo = TRUE, message=FALSE, warning=FALSE}
#load the data
load(file = system.file("extdata", "camden.rda",
                        package="stppSim"))
boundary <- camden$boundary # get boundary data
landuse <- camden$landuse # get land use data

#specifyings say 3 data sizes
pt_sizes = c(200, 1000, 2000)
#based on visual exploration
mfocal <- c()

artif_stpp <- psim_artif(n_events=pt_sizes, start_date = "2021-01-01",
  poly=boundary, n_origin=50, resistance_feat = landuse,
  field = "restrVal",
  n_foci=5, foci_separation = 10, mfocal = NULL,
  conc_type = "dispersed",
  p_ratio = 20, s_threshold = 50, step_length = 20,
  trend = "stable", first_pDate=NULL,
  slope = NULL,show.plot=FALSE, show.data=FALSE)
```

The processing time on an Intel Core i7-7500CPU @ 2.70GHz, 16.0GB RAM PC is 30.5 minutes. However, the processing time is just 3 minutes if `resistance_feat` is set to NULL. 

To preview the output:

```{r eval=FALSE}
head(artif_stpp)
``` 

Figure 4 is the spatial point patterns (`spp`) based on `n_events=1000` argument in the code above. ***Note:*** the spatial pattern is likely to change each time the code is re-run, due to the random elements in the function. The spatial patterns and clustering of events can be controlled by manipulating the arguments that control the properties of the spatial components (e.g., `n_origin`, `mfocal`, `foci_separation`, `n_foci`, etc.) and the ones that control the properties of the walkers (e.g. `step_length`, `s_threshold`, `p_ratio`). Figure 4b.1 is the result when `mfocal` argument is set as `c(530230, 182302)` (the point indicated as red dot on the map). Figure `4b.2` modifies `4b.1` by increasing the `foci_separation` argument to `30` (see the manual for explanation on `foci_separation`). Lastly, Figure `4b.3` modifies `4b.1` by increasing the spatial perception of the walkers (i.e., `s_threshold`) from `50` to `250`, as well as the speed at which they move (i.e., `step_length`) from `20` to `50`. 

```{r fig4, echo=FALSE, out.width="100%", out.height="100%", fig.align = "center", fig.cap="Simulated spatial point patterns of Camden"}
knitr::include_graphics(paste(path, "fromscratch.png", sep=""))
```

Since the arguments that control the global temporal patterns (i.e. `trend`, `first_pDate`, and `slope`) in each of the simulated data in Figure 4 are the same, then we expect the temporal patterns to be very similar. Figure 5a-d are the temporal global temporal patterns of Figure 4a, 4b.1, 4b.2, and 4b.3, respectively.

```{r fig5, echo=FALSE, out.width="40%", out.height="40%", fig.align = "center", fig.cap="Simulated global trends and patterns (gtp)"}
knitr::include_graphics(paste(path, "temporalscratch.png", sep=""))
```

If, for example, we modify the `first_pDate = "2021-02-01"` (i.e., one month after the start date of the series) and re-run the simulation, then we derive ***Figure 6*** as a global temporal patterns of ***Figure 4a***. 

```{r fig6, echo=FALSE, out.width="40%", out.height="40%", fig.align = "center", fig.cap="Gtp with an earlier first seasonal peak"}
knitr::include_graphics(paste(path, "onemonth.png", sep=""))
```


## Synthesizing `stpp`from a sample real dataset

Let us extract 30% random sample of the total theft crimes of Camden, then utilize the sample to synthesize `full` data. 

```{r eval=FALSE, message=FALSE, warning=FALSE}

data(camden_crimes)

#get the 'theft' crime
theft <- camden_crimes %>%
  filter(type == "Theft")

#total no. of records
nrow(theft)
```

```{r eval=FALSE, message=FALSE, warning=FALSE}
#specify the proportion to extract
sample_size <- 0.3 #i.e., 30%

set.seed(1000)
dat_sample <- theft[sample(1:nrow(theft),
  round((sample_size * nrow(theft)), digits=0),
  replace=FALSE),1:3]

#check the number of records
nrow(dat_sample)
```

It is nice to first preview the spatial distribution of the sample data, in order to help us define certain spatial parameters, such as `n_origin` and `s_threshold`.

Below code plots the points based on their `xy` location:

```{r eval=FALSE, message=FALSE, warning=FALSE}
plot(dat_sample$x, dat_sample$y,
    pch = 16,
     cex = 1,
     main = "Sample data at unique locations",
     xlab = "x",
     ylab = "y")
```
***Figure 7a*** is the point patterns of the sample data sets. Typically, real crime datasets are aggregated to certain nearest snap points (e.g. centroids of square grids) during data recording. Therefore, in order to truly reveal or visualize the spatial clustering of a real crime data, there is a need to aggregate the points by unique locations. Thus, the following code aggregate points by unique locations and then generate the point patterns shown in ***Figure 7b***:

```{r eval=FALSE, message=FALSE, warning=FALSE}
agg_sample <- dat_sample %>%
  mutate(y = round(y, digits = 0))%>%
  mutate(x = round(x, digits = 0))%>%
  group_by(x, y) %>%
  summarise(n=n()) %>% 
  mutate(size = as.numeric(if_else((n >= 1 & n <= 2), paste("1"),
                        if_else((n>=3 & n <=5), paste("2"), paste("2.5")))))

dev.new()
itvl <- c(1, 2, 2.5)
plot(agg_sample$x, agg_sample$y,
     pch = 16,
     cex=findInterval(agg_sample$size, itvl),
     main = "Sample data aggregated at unique location",
     xlab = "x",
     ylab = "y")
legend("topright", legend=c("1-2","3-5", ">5"), pt.cex=itvl, pch=16)

#hist(agg_sample$size)
```


```{r fig7, echo=FALSE, out.width="100%", out.height="100%", fig.align = "center", fig.cap="Setting an earlier first seasonal peak"}
knitr::include_graphics(paste(path, "samplerealvssampleaggregated.png", sep=""))
```

From Figure 7b, it can be seen that the southern part of Camden has the highest concentration of theft crime. The spatial distribution of sample data points can be used to guide the users in setting certain spatial parameters. For example, to ensure a narrower spatial spread of the points to be simulated, a user can either decrease the value of `n_origin`, or the values of `s_threshold` and `step_length`. 

In general, to guide the selection of appropriate spatial parameters for any new study area, a user might needs to understand the relative size of the new study area compared to Camden. 

Now, simulating the point data:

```{r eval=FALSE, message=FALSE, warning=FALSE}

#As the actual size of any real (full) dataset
#would not be known, therefore we will presume
#the `n_events` to be `2000`. In practice, a user can 
#infer this value from other sources, such as,
#similar crimes data, population data, etc.

#To simulate
sim_fullData <- psim_real(n_events=2000, ppt=dat_sample,
  start_date = NULL, poly = NULL, s_threshold = NULL,
  step_length = 20, n_origin=50, restriction_feat=landuse, 
  field=NA, p_ratio=20, crsys = "EPSG:27700")

#plot(dat_sample$x, dat_sample$y) #preview

```

Preview the results:

```{r eval=TRUE, echo=FALSE, warning=FALSE}
#read
load(file="C:/Users/monsu/Documents/GitHub/stppSim backup/simulation_for_vignette/sim_fullData.rda")
sim_d <- sim_fullData[[1]]

```

```{r eval=TRUE, echo=TRUE, warning=FALSE}

summary(sim_fullData)

```
In order to access the data frame containing the simulated data as in the example above, type: `sim_fullData[[1]]`. In the case of a vector argument for `n_events`, use `sim_fullData[[1]]`, `sim_fullData[[2]]`, `sim_fullData[[3]]`, and so on. The remaining objects of the simulation outputs can be accessed by simply typing: `sim_fullData$origins` to access the list of origins generated (for example). 

### Comparing simulated data and full real data

We will employ both `visual` and `statistical` approaches to compare the spatial and temporal patterns of the simulated data and the full real data (i.e., 100% data size). 

* ***Visual approach***

The `visual` approach involves plotting the spatial distribution of points across the space, as well as the time series of the points (aggregated by day). ***Note:*** For the spatial, the points will first need to be aggregated by unique location, such as in Figure 7b. Figure 8a and 8b are the point distribution of the simulated data and the full real data set, respectively, while Figure 9a and 9b are their respective time series plot.

```{r fig8, echo=FALSE, out.width="100%", out.height="100%", fig.align = "center", fig.cap="Setting an earlier first seasonal peak"}
knitr::include_graphics(paste(path, "simvsreal_spatial.png", sep=""))
```

Two things are important to note in Figure 8, namely; the `total number of points` and the `clustering of points`. A user would normally have no idea of the total number of real data in reality, so by specifying `n_events=2000`, we are mimicking a real life scenario. Secondly, the real data (Figure 8b) shows much higher clustering of points at unique locations; this reflects the crime recording practice in which points are snapped to reference locations nearest to incidents. However, our simulation does not attempts to aggregate points to any reference locations.

```{r fig9, echo=FALSE, out.width="100%", out.height="100%", fig.align = "center", fig.cap="Global temporal pattern of (a) simulated and (b) full real data set "}
knitr::include_graphics(paste(path, "simvsreal_temporal.png", sep=""))
```

It can be seen from ***Figure 9*** that the temporal patterns of both the simulated and the real data appear very similar. They both have similar short term patterns (red lines), which is steadily rising over time.

* ***Statistical approach***

In order to conduct a statistical comparison of simulated and real data set, in spatial and temporal dimension, we utilize [Pearson's Coefficient](https://www.statisticshowto.com/probability-and-statistics/correlation-coefficient-formula/). For the spatial, we aggregated the data sets to the regular square grids, match the counts by grids ids, and calculate the correlation measure. The analysis was conducted using three different grid sizes (i.e. `150sq.mts`, `250sq.mts`, and `400sq.mts`) to assess how the correlation changes with spatial scale.

For the temporal, we also aggregated the two data sets at three temporal scales, namely; `daily`, `weekly`, and `monthly`. Table 1 shows the correlation values indicating the similarities between the two data sets.

```{r table1, results='asis', echo=FALSE, tidy.opts=list(width.cutoff=50)}
table <- data.frame(cbind(Dimension = c("Spatial", "","","Temporal","",""),
      Scale_sq.mts = c(150, 250, 400, "Daily", "Weekly", "Monthly"),
      Corr.Coeff = c(.50, .62, .78, .34, .78, .93)))

knitr::kable(table, caption = "Table 1. `Correlation between simulated and real data sets`", row.names=FALSE, align=c("l", "r", "r"))
```

There are strong similarities between the simulated and the real data sets in both spatial and temporal dimensions, except at the `daily` temporal scale in which the similarity is weak. This is however expected given the level of randomness at such finer scale, coupled with the fact that the daily stamp of the 
real data set was randomly generated (see the manual on the details of `police.uk` data set). As the aggregation increases, either in the spatial or temporal dimension, the data becomes very similar, with correlation coefficients of `.78` and `.93`, for the spatial and the temporal dimensions, respectively. 

## Setting simulation parameters for a different study area

All the parameters (arguments) as used in this vignette are expected to produce similar effects for any study area, except for three of the parameters that control the spatial distributions of simulated points. These three are `n_origin`, `s_threshold` and `step_length`. A user will need to set the appropriate values for these parameter to produce point patterns that are well-spread across the space. As the size of the study area increases and decreases, we expect these three arguments to be "proportionally" scaled up and scaled down, respectively. ***Note***: We recommend that a user only scale either {`n_origin`} or {`s_threshold` and `step_length`}. 

As a result, we provided the functon `compare_areas()` to allow a user to compare the size of any new study area with another study area whose simulation parameters are already established, such as the `Camden` (in this vignette). By inputing these polygon shapefile covering the two areas into the function, then a factor is generated, which indicates how large or small `Camden` is relative to the new study area. This factor can then be used to multiple the aforementioned parameters. For example, if `Camden` is 3 times smaller than the new area, then we multiply either {`n_origin`} or {`s_threshold` and `step_length`} by 3. You use divide if `Camden` is bigger. Using {`s_threshold` and `step_length`} is a better option computation-wise.

We can demonstrate the utility of `compare_areas()` function by comparing Birmingham area of UK with Camden area, as follows:

```{r eval=FALSE, echo=TRUE, warning=FALSE}

#load 'area1' object - boundary of Camden, UK
load(file = system.file("extdata", "camden.rda",
                        package="stppSim"))

camden_boundary = camden$boundary

#load 'area2' - boundary of Birmingham, UK
load(file = system.file("extdata", "birmingham_boundary.rda",
                        package="stppSim"))

#run the comparison
output <- compare_areas(area1 = camden_boundary,
              area2 = birmingham_boundary, display_output = FALSE)

```

The comparison (and the factor) can be printed as follows:

```{r eval=FALSE, echo=FALSE, warning=FALSE}
output$comparison
```
The above code returns the string `#-----'area2' is 12.3 times bigger than 'area1'-----#`. Therefore, either {`n_origin`} or {`s_threshold` and `step_length`} should be multiplied by `12.3`. To retrieve the plot showing the relative sizes of the two areas: 

```{r eval=FALSE, echo=TRUE, warning=FALSE}
output$plot
```

```{r fig10, echo=FALSE, out.width="100%", out.height="100%", fig.align = "center", fig.cap="Comparing Camden and Birmingham"}
knitr::include_graphics(paste(path, "camdenvsbirmingham.png", sep=""))
```


## Discussion

This vignette has demonstrated the utility of the two main functions of the `stppSim` package for generating fine-grained spatiotemporal point patterns; (1) `psim_artif` - for generating data from scratch and (2) `psim_real` for generating data from a sample real data set. The vignette discusses the parameters that control the three main simulation elements, namely; 'Walkers (agents)', the `landscape` (spatial), and the `temporal` dimension. These parameters should be modified in accordance with the subject under study. The package has a wide potential areas of applications, including the study of human offending behaviours and crime, the study of foraging animals and their scores, and the study of disease carriers and infections. We will continue to update the package for wider application.   

We encourage users to report any bugs encountered while using the package so that they can be fixed immediately. Welcome contributions to this package which will be acknowledged accordingly. 
